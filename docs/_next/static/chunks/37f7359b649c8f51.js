(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,1521,(e,n,l)=>{"use strict";Object.defineProperty(l,"__esModule",{value:!0}),Object.defineProperty(l,"warnOnce",{enumerable:!0,get:function(){return c}});let c=e=>{}},79537,e=>{e.v({AElig:"Æ",AMP:"&",Aacute:"Á",Acirc:"Â",Agrave:"À",Aring:"Å",Atilde:"Ã",Auml:"Ä",COPY:"©",Ccedil:"Ç",ETH:"Ð",Eacute:"É",Ecirc:"Ê",Egrave:"È",Euml:"Ë",GT:">",Iacute:"Í",Icirc:"Î",Igrave:"Ì",Iuml:"Ï",LT:"<",Ntilde:"Ñ",Oacute:"Ó",Ocirc:"Ô",Ograve:"Ò",Oslash:"Ø",Otilde:"Õ",Ouml:"Ö",QUOT:'"',REG:"®",THORN:"Þ",Uacute:"Ú",Ucirc:"Û",Ugrave:"Ù",Uuml:"Ü",Yacute:"Ý",aacute:"á",acirc:"â",acute:"´",aelig:"æ",agrave:"à",amp:"&",aring:"å",atilde:"ã",auml:"ä",brvbar:"¦",ccedil:"ç",cedil:"¸",cent:"¢",copy:"©",curren:"¤",deg:"°",divide:"÷",eacute:"é",ecirc:"ê",egrave:"è",eth:"ð",euml:"ë",frac12:"½",frac14:"¼",frac34:"¾",gt:">",iacute:"í",icirc:"î",iexcl:"¡",igrave:"ì",iquest:"¿",iuml:"ï",laquo:"«",lt:"<",macr:"¯",micro:"µ",middot:"·",nbsp:" ",not:"¬",ntilde:"ñ",oacute:"ó",ocirc:"ô",ograve:"ò",ordf:"ª",ordm:"º",oslash:"ø",otilde:"õ",ouml:"ö",para:"¶",plusmn:"±",pound:"£",quot:'"',raquo:"»",reg:"®",sect:"§",shy:"­",sup1:"¹",sup2:"²",sup3:"³",szlig:"ß",thorn:"þ",times:"×",uacute:"ú",ucirc:"û",ugrave:"ù",uml:"¨",uuml:"ü",yacute:"ý",yen:"¥",yuml:"ÿ"})},27208,e=>{e.v({0:"�",128:"€",130:"‚",131:"ƒ",132:"„",133:"…",134:"†",135:"‡",136:"ˆ",137:"‰",138:"Š",139:"‹",140:"Œ",142:"Ž",145:"‘",146:"’",147:"“",148:"”",149:"•",150:"–",151:"—",152:"˜",153:"™",154:"š",155:"›",156:"œ",158:"ž",159:"Ÿ"})},73850,e=>{"use strict";var n=e.i(45100);let l=(0,e.i(51849).createIcon)({iconProps:{useFillCurrentColor:!0},viewBox:"0 0 156 94",paths:(0,n.jsx)("path",{d:"M0,31.18h31.18v62.56H0V31.18Zm155.46,5.67v56.89h-31.18V45.36c0-7.83-6.34-14.18-14.17-14.18h-17.01c.29,1.85,.44,3.74,.44,5.67v56.89h-31.18V45.36c0-7.83-6.35-14.18-14.17-14.18H31.18V0h25.51c13.15,0,24.69,6.89,31.21,17.25,2.62,4.15,4.43,8.86,5.2,13.92V0h25.51c20.35,0,36.85,16.5,36.85,36.85Z"})});e.s(["IconMLogo",0,l])},7823,e=>{"use strict";function n(e,n){if(null==e)return{};var l={};for(var c in e)if(({}).hasOwnProperty.call(e,c)){if(-1!==n.indexOf(c))continue;l[c]=e[c]}return l}e.s(["default",()=>n])},37215,e=>{"use strict";function n(){return(n=Object.assign.bind()).apply(null,arguments)}e.s(["default",()=>n])},22480,e=>{"use strict";let n=(0,e.i(64334).createContext)({currentId:"",onLinkClick:()=>{},linkMap:{current:new Map}});e.s(["AnchorContext",0,n])},98319,e=>{"use strict";var n=e.i(64334);function l(...e){return(0,n.useCallback)(n=>{e.forEach(e=>{"function"==typeof e?e(n):null!=e&&(e.current=n)})},e)}e.s(["useComposedRefs",()=>l])},88036,59013,e=>{"use strict";var n=e.i(45100),l=e.i(64334),c=e.i(22480);function d(e){let n=(0,l.useRef)(null);return n.current=e,(0,l.useCallback)((...e)=>n.current?.(...e),[])}e.s(["useEvent",()=>d],59013);var o=e.i(96224);function r(e,n){try{return e.querySelector(n)}catch(e){return null}}function t({scrollContainer:e,targetId:n,offset:l,isScrolling:c}){var d,t;if(!n)return;let i=r(document,`#${CSS.escape(n)}`);if(!i)return;let s=e.current,a=((void 0===(d=s)&&(d=window),d)&&(d===window?Math.ceil(window.pageYOffset):d.scrollTop)||0)+((e,n)=>{if(!e.getClientRects().length)return 0;let l=e.getBoundingClientRect();return l.width||l.height?n&&n!==window?l.top-n.getBoundingClientRect().top:(n=e.ownerDocument.documentElement,l.top-n.clientTop):l.top})(i,s)+l;(c.current=!0,(0,o.isWindow)(s))?s.scrollTo((void 0===(t=s)&&(t=window),t)&&(t===window?Math.ceil(window.pageXOffset||window.scrollX):t.scrollLeft)||0,a):s.scrollTop=a}function i({targetId:e,linkMap:n,wrapperRef:l,currentId:c,setCurrentId:d,onChange:o}){e&&l.current&&n.current.get(e)&&e!==c&&d(e).then(()=>{o?.(e,c)})}var s=e.i(98319);let a=(0,l.forwardRef)((e,a)=>{let{scrollContainer:h,offset:x=0,children:u,onChange:j,queryKey:m="anchor-id",isCloseInitAnchor:f,...p}=e,{currentId:v,onLinkClick:g,wrapperRef:y,linkMap:C}=function({propScrollContainer:e,onChange:n,offset:c,queryKey:s,isCloseInitAnchor:a}){var h;let x,u,j=(0,l.useRef)(null),m=(0,l.useRef)(null),f=(0,l.useRef)(new Map),p=(0,l.useRef)(!1),[v,g]=function(e){let[n,c]=(0,l.useState)({value:"",resolve:e=>{}});return(0,l.useEffect)(()=>{n.resolve(n.value)},[n]),[n.value,e=>new Promise(n=>{c(l=>{let c=e;return"function"==typeof e&&(c=e(l.value)),{value:c,resolve:n}})})]}(0),y=d(()=>{if(p.current)return;let e=function({linkMap:e,scrollContainer:n}){let l=n.current,c=((0,o.isWindow)(l)?document.documentElement||document.body:l).getBoundingClientRect(),d=Array.from(e.current.keys()),t=[];for(let e of d){let n=r(document,"#"+CSS.escape(e));if(n){let{top:e}=n.getBoundingClientRect(),d=(0,o.isWindow)(l)?e:e-c.top;d>=0&&t.push({element:n,top:d})}}return 0===t.length?null:t.reduce((e,n)=>e.top<=n.top?e:n).element}({linkMap:f,scrollContainer:m});e?.id&&i({targetId:e.id,linkMap:f,wrapperRef:j,currentId:v,setCurrentId:g,onChange:n})}),C=d((h=()=>{y(),p.current=!1},x=null,(u=(...e)=>{x||(x=setTimeout(()=>{x=null,h(...e)},30))}).cancel=()=>{x&&(clearTimeout(x),x=null)},u));return(0,l.useEffect)(()=>(m.current=(0,o.isString)(e)?r(document,e):e||window,m.current?.addEventListener("scroll",C),()=>{m.current?.removeEventListener("scroll",C)}),[C,e]),(0,l.useEffect)(()=>{if(!a)return void C();let e=new URLSearchParams(new URL(window.location.href).search).get(s);e&&(i({targetId:e,linkMap:f,wrapperRef:j,currentId:v,setCurrentId:g,onChange:n}),t({scrollContainer:m,targetId:e,offset:c,isScrolling:p}))},[]),{onScroll:C,currentId:v,onLinkClick:function(e,l){e.preventDefault(),i({targetId:l,linkMap:f,wrapperRef:j,currentId:v,setCurrentId:g,onChange:n}),t({scrollContainer:m,targetId:l,offset:c,isScrolling:p})},wrapperRef:j,scrollContainer:m,linkMap:f}}({propScrollContainer:h,onChange:j,offset:x,queryKey:m,isCloseInitAnchor:f});return(0,n.jsx)(c.AnchorContext.Provider,{value:{currentId:v,linkMap:C,onLinkClick:g},children:(0,n.jsx)("div",{...p,ref:(0,s.useComposedRefs)(y,a),children:u})})});e.s(["Anchor",0,a],88036)},69438,e=>{"use strict";var n=e.i(45100),l=e.i(64334),c=e.i(22480),d=e.i(98319);let o=(0,l.forwardRef)((e,o)=>{let{onLinkClick:r,linkMap:t,currentId:i}=(0,l.useContext)(c.AnchorContext),{onClick:s,targetId:a,children:h,className:x,activeClassName:u,...j}=e,m=(0,l.useRef)(null);return(0,l.useEffect)(()=>{var e;return e=m.current,a&&t.current.set(a,e),()=>{t.current.delete(a)}},[a,t]),(0,n.jsx)("div",{ref:(0,d.useComposedRefs)(o,m),...j,onClick:e=>{e.stopPropagation(),s?.(e),r?.(e,a)},"data-target-id":a,className:i===a?u:x,children:h})});e.s(["AnchorLink",0,o],69438)},93562,e=>{"use strict";var n=e.i(88036),l=e.i(69438),c=e.i(22480);let d={Root:n.Anchor,Link:l.AnchorLink,Context:c.AnchorContext};e.s(["Anchor",()=>d])},53827,56245,e=>{"use strict";var n=e.i(45100),l=e.i(93562),c=e.i(37812);function d({items:e,...d}){return(0,n.jsx)(l.Anchor.Root,{...d,className:"sticky top-[90px] overflow-y-auto h-[calc(100vh-100px)]",children:function e(d){return Array.isArray(d)?d.map((d,o)=>(0,n.jsxs)(l.Anchor.Link,{targetId:d.text,children:[(0,n.jsx)(c.LinkItem,{item:d}),e(d.items)]},d.text||o)):null}(e)})}e.s(["Catalog",()=>d],56245),e.s([],53827)},77879,e=>{"use strict";var n=e.i(45100),l=e.i(18694);e.i(82928);var c=e.i(72304),d=e.i(47445),o=e.i(69389);function r(e){let r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,l.useMDXComponents)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.H1,{subheading:"技术难点解析",children:"我去！modal 组件这么难写你知道吗？"}),"\n",(0,n.jsx)(c.ImageTypography,{src:"/modal/modal.webp",fill:!0,alt:"button"}),"\n",(0,n.jsx)(r.h2,{children:"前言"}),"\n",(0,n.jsxs)(r.p,{children:["很多人对于 ",(0,n.jsx)(r.code,{children:"modal"})," 组件的第一印象就是一个弹框居中，然后一个黑色蒙层 ",(0,n.jsx)(r.code,{children:"fixed"})," 布局放在后面，感觉很简单啊，但是深入研究各个组件库的 ",(0,n.jsx)(r.code,{children:"modal"})," 源码，发现技术细节有很多，不信你就接着看！保证没做过 ",(0,n.jsx)(r.code,{children:"modal"})," 组件的同学不知道。\n我简单列一下技术难点,你可以测试一下你用的组件库是否注意这些细节了，欢迎留言讨论！"]}),"\n",(0,n.jsx)(r.h2,{children:"如何处理滚动条"}),"\n",(0,n.jsx)(r.h3,{children:"为什么要处理滚动条样式？"}),"\n",(0,n.jsxs)(r.p,{children:["首先，一般 ",(0,n.jsx)(r.code,{children:"modal"})," 框弹出的时候，我们是不想页面还能滚动的，这个如何处理？一般情况我们会给 ",(0,n.jsx)(r.code,{children:"body"}),"（此时往往会给 modal 设置 ",(0,n.jsx)(r.code,{children:"position: fixed"}),"） 或者是你自定义的挂载容器（此时往往会给 modal 设置 ",(0,n.jsx)(r.code,{children:"position: absolute"}),"）。"]}),"\n",(0,n.jsxs)(r.p,{children:["设置 ",(0,n.jsx)(r.code,{children:"overflow: hidden"})," 样式。但此时又出现一个问题，如果之前有滚动条，",(0,n.jsx)(r.code,{children:"overflow: hidden"})," 会导致滚动条消失，滚动条原本就占了一定宽度的，当消失的瞬间，宽度消失，那么意味着容器就会占据这部分消失的空间。\n所以布局上就会有 ",(0,n.jsx)(r.code,{children:"抖一下"})," 的感觉。为了不让用户感知到这个过程，我们需要在 ",(0,n.jsx)(r.code,{children:"modal"})," 弹出的时候，给 ",(0,n.jsx)(r.code,{children:"body"})," 或者是你自定义的挂载容器的 ",(0,n.jsx)(r.code,{children:"style"})," ",(0,n.jsx)(r.code,{children:"width"})," 值需要减去滚动条的宽度。"]}),"\n",(0,n.jsx)(r.h2,{children:"如何解决嵌套 modal"}),"\n",(0,n.jsxs)(r.p,{children:["指的是是点击按钮弹出 ",(0,n.jsx)(r.code,{children:"modal"})," 弹窗，弹窗里又有一个按钮，点击之后再之前的基础上又有一个 ",(0,n.jsx)(r.code,{children:"modal"}),"，以此类推，嵌套的 ",(0,n.jsx)(r.code,{children:"modal"})," 弹窗。"]}),"\n",(0,n.jsx)(r.h3,{children:"为什么要处理嵌套 modal？"}),"\n",(0,n.jsxs)(r.p,{children:["首先数据结构的设计上，最后天然支持多个 ",(0,n.jsx)(r.code,{children:"modal"})," 弹窗，例如设计为数组，但还有一个问题，就是刚才我们说了，弹出 ",(0,n.jsx)(r.code,{children:"modal"})," 会给容器处理添加 ",(0,n.jsx)(r.code,{children:"overflow: hidden"})," 样式，以及更改 ",(0,n.jsx)(r.code,{children:"width"})," 值，那么什么时候恢复样式呢？是不是还不能是关闭 ",(0,n.jsx)(r.code,{children:"modal"})," 的时候，\n因为有可能是有多个 ",(0,n.jsx)(r.code,{children:"modal"}),"，只有关闭最后一个的时候，才需要恢复容器原先的样式。"]}),"\n",(0,n.jsx)(r.h3,{children:"解决方案"}),"\n",(0,n.jsxs)(r.p,{children:["这里的解决方案一般有两种，一种是例如 ",(0,n.jsx)(r.code,{children:"material ui"}),"，",(0,n.jsx)(r.code,{children:"chakra-ui"}),", 小米公司的 ",(0,n.jsx)(r.code,{children:"modal"})," 组件，都是用一个数据结构保存所有 ",(0,n.jsx)(r.code,{children:"modal"}),"，然后每次关闭一个 ",(0,n.jsx)(r.code,{children:"modal"}),"，就去所有 ",(0,n.jsx)(r.code,{children:"modal"})," 里找是否是最后一个 ",(0,n.jsx)(r.code,{children:"modal"}),"，如果是最后一个才恢复 ",(0,n.jsx)(r.code,{children:"body"})," 原本的 ",(0,n.jsx)(r.code,{children:"style"}),"。"]}),"\n",(0,n.jsxs)(r.p,{children:["第二种是字节 ",(0,n.jsx)(r.code,{children:"arco design"})," 的处理方法，还是比较巧妙的，我的组件库也学习了这种方式。"]}),"\n",(0,n.jsxs)(r.p,{children:["请看下面的 ",(0,n.jsx)(r.code,{children:"useOverflowHidden"}),", 我们详细的看下如何处理隐藏 ",(0,n.jsx)(r.code,{children:"body"})," 滚动条和恢复的时机和具体方法。"]}),"\n",(0,n.jsx)(d.CodeBlock,{code:`import { useEffect, useRef } from "react";
import { resetContainerStyle, setContainerStyle } from "../utils";

export function useOverflowHidden(
  getContainer: () => HTMLElement,
  hidden: boolean
) {
const needResetContainerStyle = useRef < boolean > false;
const originContainerStyle = useRef < Partial < CSSStyleDeclaration >> {};

useEffect(() => {
  hidden
    ? setContainerStyle({
        needResetContainerStyle,
        originContainerStyle,
        getContainer,
      })
    : resetContainerStyle({
        needResetContainerStyle,
        originContainerStyle,
        getContainer,
      });
  return () => {
    resetContainerStyle({
      needResetContainerStyle,
      originContainerStyle,
      getContainer,
    });
  };
}, [getContainer, hidden]);
}`,language:"jsx"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"getContainer"})," 代码要挂载到 ",(0,n.jsx)(r.code,{children:"html"})," 文档流哪个 ",(0,n.jsx)(r.code,{children:"dom"})," 中，我们默认是 ",(0,n.jsx)(r.code,{children:"body"})," 元素中"]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"hidden"})," 是指是否弹框的时候，我们需要黑色蒙层，也就是有时候我们传参不需要这个蒙层，也就意味着我们不想让 ",(0,n.jsx)(r.code,{children:"body"})," 滚动条消失，所以我们在看到 ",(0,n.jsx)(r.code,{children:"modal"})," 弹框的同时，也能滚动后面的页面，当然，我们这里大家可以看为是 ",(0,n.jsx)(r.code,{children:"true"}),"，我们是需要黑色蒙层的"]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"needResetContainerStyle"})," 用来记录是否重置 ",(0,n.jsx)(r.code,{children:"body"})," 的 ",(0,n.jsx)(r.code,{children:"style"})," 样式，只有调用 ",(0,n.jsx)(r.code,{children:"setContainerStyle"})," 方法后，并且是第一个触发的 ",(0,n.jsx)(r.code,{children:"modal"})," 框，这个值才会是 ",(0,n.jsx)(r.code,{children:"true"})]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["我们马上看下 ",(0,n.jsx)(r.code,{children:"setContainerStyle"}),"，也就是设置 ",(0,n.jsx)(r.code,{children:"body"})," 滚动条隐藏的函数："]}),"\n",(0,n.jsx)(d.CodeBlock,{code:`import { getScrollBarWidth } from "./getScrollBarWidth";

/**
* Hides the container's scroll bar
*/
export const setContainerStyle = ({
  getContainer,
  needResetContainerStyle,
  originContainerStyle,
}) => {
  const container = getContainer();
  if (container && container.style.overflow !== "hidden") {
    /**
    * @zh 记录container的style属性, 因为后续要将container.style.overflow设为hidden
    * @en Record the container's style property, because I'll set container.style.overflow to hidden later
    */
    const originStyle = container.style;

    /**
    * @zh 记录是否 container.style.overflow 被覆盖为hidden
    * @en Note whether container.style.overflow is overwritten as hidden
    */
    needResetContainerStyle.current = true;

    const containerScrollBarWidth = getScrollBarWidth(container);
    if (containerScrollBarWidth) {
      originContainerStyle.current.width = originStyle.width;
      container.style.width = \`calc(\${
        container.style.width || "100%"
      } - \${containerScrollBarWidth}px)\`;
    }

    /**
    * @zh 设置container的overflow为hidden
    * @en Set container overflow to hidden
    */
    originContainerStyle.current.overflow = originStyle.overflow;
    container.style.overflow = "hidden";
  }
};`,language:"jsx"}),"\n",(0,n.jsx)(r.p,{children:"上面的重点有两部分"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["需要将 ",(0,n.jsx)(r.code,{children:"container"})," (默认是 ",(0,n.jsx)(r.code,{children:"body"})," 元素) 的 ",(0,n.jsx)(r.code,{children:"style.overflow"})," 设置为 ",(0,n.jsx)(r.code,{children:"hidden"}),"。",(0,n.jsx)(r.code,{children:"needResetContainerStyle"})," 也记录下，已经设置过 ",(0,n.jsx)(r.code,{children:"container"})," 的 ",(0,n.jsx)(r.code,{children:"style.overflow"})," 样式了用来后续还原样式。"]}),"\n",(0,n.jsxs)(r.li,{children:["需要记录下 ",(0,n.jsx)(r.code,{children:"container"})," 的 ",(0,n.jsx)(r.code,{children:"width"})," 设置的值减去滚动条的宽度。因为如果不减去滚动条宽度，那么当 ",(0,n.jsx)(r.code,{children:"container"})," 的 ",(0,n.jsx)(r.code,{children:"width"})," 减小了，视觉上会有抖动，这是个很细的交互细节。"]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{children:"如何锁定焦点"}),"\n",(0,n.jsx)(r.h3,{children:"什么是锁定焦点"}),"\n",(0,n.jsxs)(r.p,{children:["当你打开 ",(0,n.jsx)(r.code,{children:"modal"})," 的时候，在键盘上按下 ",(0,n.jsx)(r.code,{children:"tab"})," 键，会出现 ",(0,n.jsx)(r.code,{children:"button"})," 元素 ",(0,n.jsx)(r.code,{children:"focus"})," 的状态。"]}),"\n",(0,n.jsx)(c.ImageTypography,{src:"/modal/focus.jpg",fill:!0,alt:"modal focus"}),"\n",(0,n.jsxs)(r.p,{children:["上图所示的 ",(0,n.jsx)(r.code,{children:"focus"})," 状态，会在你按下回车键的时候触发这个按钮的 ",(0,n.jsx)(r.code,{children:"onClick"})," 事件。而且你一直按 ",(0,n.jsx)(r.code,{children:"Tab"})," 键，焦点只会在当前 ",(0,n.jsx)(r.code,{children:"Modal"})," 框里，不会移除到 ",(0,n.jsx)(r.code,{children:"Modal"})," 框外，这种 ",(0,n.jsx)(r.code,{children:"focus"})," 状态锁定技术是需要解决的。\n并且有些同学可能不了解 ",(0,n.jsx)(r.code,{children:"tabIndex"}),",有兴趣的同学可以搜索一下，通过 ",(0,n.jsx)(r.code,{children:"tabIndex"}),",我们可以让关闭按钮，也就是右上角的 ",(0,n.jsx)(r.code,{children:"x"})," 也能获取焦点，我的组件库并没有处理这个细节，是因为按 ",(0,n.jsx)(r.code,{children:"ESC"})," 键就可以关闭弹窗，这样做我感觉多此一举。"]}),"\n",(0,n.jsx)(r.p,{children:"在网页中，模态框（Modal）、弹出层（Dialog）等组件出现时，通常希望用户的键盘焦点始终被限制在这个弹出层内部，防止按下 Tab 键后焦点跳出模态框、误操作到页面其他区域。这种机制被称为 “焦点陷阱（Focus Trap）”。"}),"\n",(0,n.jsx)(r.h3,{children:"解决方案"}),"\n",(0,n.jsx)(r.p,{children:"我们会用一段简单的代码来实现这个功能。后面会有详细的讲解。"}),"\n",(0,n.jsx)(d.CodeBlock,{code:`function createFocusTrap(element) {
const focusableElements = Array.from(
  element.querySelectorAll(
    'a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
  )
);

let firstFocusableElement = focusableElements[0];
let lastFocusableElement = focusableElements[focusableElements.length - 1];

function handleKeyDown(event) {
  if (event.key === "Tab") {
    if (event.shiftKey && document.activeElement === firstFocusableElement) {
      event.preventDefault();
      lastFocusableElement.focus();
    } else if (
      !event.shiftKey &&
      document.activeElement === lastFocusableElement
    ) {
      event.preventDefault();
      firstFocusableElement.focus();
    }
  }
}

element.addEventListener("keydown", handleKeyDown);
element.focus();
}`,language:"jsx"}),"\n",(0,n.jsxs)(r.p,{children:["这段代码的核心目标，就是在指定的容器元素中创建这样一个焦点陷阱，让用户在使用键盘 ",(0,n.jsx)(r.code,{children:"Tab"})," 或 ",(0,n.jsx)(r.code,{children:"Shift + Tab"})," 切换焦点时，始终在容器内循环切换焦点。"]}),"\n",(0,n.jsx)(r.p,{children:"核心分为三部分："}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["找到容器内所有可聚焦的元素\n通过选择器筛选出 ",(0,n.jsx)(r.code,{children:"a"}),"、",(0,n.jsx)(r.code,{children:"button"}),"、",(0,n.jsx)(r.code,{children:"input"}),"、",(0,n.jsx)(r.code,{children:"select"}),"、",(0,n.jsx)(r.code,{children:"textarea"})," 等常见可聚焦元素，以及显式设置了 ",(0,n.jsx)(r.code,{children:"tabindex"})," 的元素，并将它们存入数组中，方便后续处理。"]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsx)(r.p,{children:"记录首尾焦点节点\n取出第一个和最后一个可聚焦元素，分别用于判断焦点循环的“边界条件”。"}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["拦截键盘事件，实现循环焦点\n监听容器的 ",(0,n.jsx)(r.code,{children:"keydown"})," 事件。当用户按下 ",(0,n.jsx)(r.code,{children:"Tab"})," 键：\n如果是 ",(0,n.jsx)(r.code,{children:"Shift + Tab"})," 且当前焦点在第一个元素上，就阻止默认行为，让焦点跳到最后一个元素；\n如果是普通 ",(0,n.jsx)(r.code,{children:"Tab"})," 且当前焦点在最后一个元素上，就跳回第一个元素。\n这样就实现了焦点在容器内部首尾循环，形成“焦点陷阱”。"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{children:"难点：支持函数调用"}),"\n",(0,n.jsx)(r.p,{children:"很多弹窗类的组件，在实际业务中，很多都是点击事件触发，或者某个用户触发交互事件触发的，而这些交互事件往往是回调函数的形式存在。\n那么这些弹窗如果能是函数调用的方式弹出，就会非常方便。例如："}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["Modal.add 增加 ",(0,n.jsx)(r.code,{children:"modal"})," 组件"]}),"\n",(0,n.jsxs)(r.li,{children:["Modal.remove 关闭 ",(0,n.jsx)(r.code,{children:"modal"})," 组件"]}),"\n",(0,n.jsxs)(r.li,{children:["Modal.update 更新 ",(0,n.jsx)(r.code,{children:"modal"})," 组件"]}),"\n",(0,n.jsxs)(r.li,{children:["Modal.removeAll 关闭所有 ",(0,n.jsx)(r.code,{children:"modal"})," 组件"]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"也就是再也不用如下的调用方式了："}),"\n",(0,n.jsx)(d.CodeBlock,{code:"<Modal />",language:"jsx"}),"\n",(0,n.jsx)(r.p,{children:"而是："}),"\n",(0,n.jsx)(d.CodeBlock,{code:`Modal.add({ ...xxx参数 });`,language:"jsx"}),"\n",(0,n.jsx)(r.h2,{children:"支持自定义 modal"}),"\n",(0,n.jsxs)(r.p,{children:["我们最终支持通过 ",(0,n.jsx)(r.code,{children:"content"})," 属性传入自定义的 ",(0,n.jsx)(r.code,{children:"modal"})," 组件。例如："]}),"\n",(0,n.jsx)(d.CodeBlock,{code:`Modal.add({ content: xx传入自定义的 Modal 组件 });`,language:"jsx"}),"\n",(0,n.jsxs)(r.p,{children:["这时候就有问题了，我们的 ",(0,n.jsx)(r.code,{children:"Modal.add"})," 如何给这个自定义 ",(0,n.jsx)(r.code,{children:"modal"})," 组件传入参数呢？然后 ",(0,n.jsx)(r.code,{children:"Modal.update"})," 更新参数的时候，还能自动更新传入到 ",(0,n.jsx)(r.code,{children:"content"})," 组件中？\n我采取了一个比较简单的方式，借助 ",(0,n.jsx)(r.code,{children:"React.cloneElement"})," 方法。类似于："]}),"\n",(0,n.jsx)(d.CodeBlock,{code:"React.cloneElement(content, { contentProps });",language:"jsx"}),"\n",(0,n.jsxs)(r.p,{children:["也就是在 ",(0,n.jsx)(r.code,{children:"Modal.add"})," 方法中传入了 ",(0,n.jsx)(r.code,{children:"contentProps"})," 参数会自动透传给 ",(0,n.jsx)(r.code,{children:"content"})," 组件。从而达到函数调用的方式传入参数的效果。"]}),"\n",(0,n.jsx)(r.h2,{children:"其它技术难点"}),"\n",(0,n.jsx)(r.p,{children:"其实还有很多细节，例如："}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"如何设计第一次获得焦点的元素。（有些表单想打开的时候，某个元素获得焦点）"}),"\n",(0,n.jsxs)(r.li,{children:["嵌套 ",(0,n.jsx)(r.code,{children:"modal"})," 设计，例如：一个 ",(0,n.jsx)(r.code,{children:"modal"})," 组件中再嵌套一个 ",(0,n.jsx)(r.code,{children:"modal"})," 组件，这个时候我们需要注意什么问题？"]}),"\n",(0,n.jsxs)(r.li,{children:["如何处理 ",(0,n.jsx)(r.code,{children:"modal"})," 组件的关闭事件。（例如：点击关闭按钮、点击蒙层、按下 ",(0,n.jsx)(r.code,{children:"ESC"})," 键）"]}),"\n",(0,n.jsx)(r.li,{children:"等等"}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["所有关于 ",(0,n.jsx)(r.code,{children:"modal"})," 组件的技术难点，欢迎加入到我们的组件库交流群中。有什么疑问都可以在群里讨论，并且会有视频直播每个组件的实现。"]}),"\n",(0,n.jsx)(r.p,{children:"更重要的是,我可以帮助你增加一些简历中的核心项目，例如我们这个组件库级别的。无论你是面试初级开发还是到前端技术专家，都会帮助你在面试中脱颖而出。"}),"\n",(0,n.jsx)(r.h2,{children:"附录"}),"\n",(0,n.jsx)(r.h3,{children:"安装 modal"}),"\n",(0,n.jsx)(d.CodeBlock,{code:`npm i @t-headless-ui/react
yarn i @t-headless-ui/react
pnpm i @t-headless-ui/react`,language:"bash"}),"\n",(0,n.jsx)(r.h3,{children:"引入和使用 modal"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"modal"})," 组件跟别的组件不太一样，首先需要你调用创建一个 ",(0,n.jsx)(r.code,{children:"store"})," 实例："]}),"\n",(0,n.jsx)(d.CodeBlock,{code:`import { createModalStore } from '@t-headless-ui/react';
const modalStore = createModalStore()
`,language:"tsx"}),"\n",(0,n.jsxs)(r.p,{children:["目的是用这个 ",(0,n.jsx)(r.code,{children:"store"})," 来管理 ",(0,n.jsx)(r.code,{children:"modal"})," 组件的状态，例如添加、删除、更新 ",(0,n.jsx)(r.code,{children:"modal"})," 组件的状态。"]}),"\n",(0,n.jsxs)(r.p,{children:["然后引入 ",(0,n.jsx)(r.code,{children:"ModalProvider"})," 组件，将 ",(0,n.jsx)(r.code,{children:"store"})," 实例作为 ",(0,n.jsx)(r.code,{children:"prop"})," 传递给 ",(0,n.jsx)(r.code,{children:"ModalProvider"})," 组件。",(0,n.jsx)(r.code,{children:"ModalProvider"})," 组件一般放在你的项目的入口文件中，\n例如 ",(0,n.jsx)(r.code,{children:"App.tsx"})," 或者 ",(0,n.jsx)(r.code,{children:"App.jsx"})," 文件。目的是初始化 ",(0,n.jsx)(r.code,{children:"Modal"})," 组件（其背后默认会在 ",(0,n.jsx)(r.code,{children:"document.body"})," 创建一个可以出现 ",(0,n.jsx)(r.code,{children:"modal"})," 信息框），当然我们也支持自定义插入\n到某个 ",(0,n.jsx)(r.code,{children:"dom"})," 元素中，一般情况使用默认的即可。"]}),"\n",(0,n.jsx)(d.CodeBlock,{code:`import { ModalProvider } from '@t-headless-ui/react';
<ModalProvider store={modalStore} />`,language:"tsx"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"ModalProvider"})," 支持传入一些全局参数，包括："]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"maskCls"}),"：指定 ",(0,n.jsx)(r.code,{children:"modal"})," 组件蒙层的类名。"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"maskStyle"}),"：指定 ",(0,n.jsx)(r.code,{children:"modal"})," 组件蒙层的样式。"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"focusLock"}),": 是否开启焦点锁定。默认是 ",(0,n.jsx)(r.code,{children:"true"}),"。"]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["以上参数也可以在使用 ",(0,n.jsx)(r.code,{children:"Modal.add"})," 方法时单独传入，会覆盖 ",(0,n.jsx)(r.code,{children:"ModalProvider"})," 组件的全局参数。"]}),"\n",(0,n.jsxs)(r.p,{children:["最后，就可以引入 ",(0,n.jsx)(r.code,{children:"modalStore"})," 开始调用了："]}),"\n",(0,n.jsx)(d.CodeBlock,{code:`<button
onClick={() =>
  modalStore.add({
    content: xxx 自己封装的 Modal 组件,
  })
}
>
open modal
</button>`,language:"tsx"}),"\n",(0,n.jsxs)(r.p,{children:["因为我们的 ",(0,n.jsx)(r.code,{children:"modal"})," 组件是一个 ",(0,n.jsx)(r.code,{children:"headless"})," 组件，所以弹出的内容完全是自定义的，在 ",(0,n.jsx)(r.code,{children:"Alert"})," 组件中，我们提供了一个简单的样例，大家可以去参考一下。"]})]})}function t(e={}){let{wrapper:c}={...(0,l.useMDXComponents)(),...e.components};return c?(0,n.jsx)(c,{...e,children:(0,n.jsx)(r,{...e})}):r(e)}function i(){return(0,n.jsx)(t,{})}let s=[{level:2,text:"前言"},{level:2,text:"如何处理滚动条",items:[{level:3,text:"为什么要处理滚动条样式？"}]},{level:2,text:"如何解决嵌套 modal",items:[{level:3,text:"为什么要处理嵌套 modal？"},{level:3,text:"解决方案"}]},{level:2,text:"如何锁定焦点",items:[{level:3,text:"什么是锁定焦点"},{level:3,text:"解决方案"}]},{level:2,text:"难点：支持函数调用"},{level:2,text:"支持自定义 modal"},{level:2,text:"其它技术难点"},{level:2,text:"附录",items:[{level:3,text:"安装 modal"},{level:3,text:"引入和使用 modal"}]}];e.i(53827);var a=e.i(56245);function h(){return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)("div",{className:"grow shrink basis-0 overflow-hidden mx-16 mt-8 mb-12",children:(0,n.jsx)(i,{})}),(0,n.jsx)("div",{className:"hidden z-10 xl:flex xl:w-48 mt-8 pl-0 shrink-0",children:(0,n.jsx)(a.Catalog,{items:s,offset:-90})})]})}e.s(["default",()=>h],77879)}]);